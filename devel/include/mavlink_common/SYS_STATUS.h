/* Software License Agreement (BSD License)
 *
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Willow Garage, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Auto-generated by genmsg_cpp from file /root/ehang_ws/src/ghost/mavlink_common/msg/SYS_STATUS.msg
 *
 */


#ifndef MAVLINK_COMMON_MESSAGE_SYS_STATUS_H
#define MAVLINK_COMMON_MESSAGE_SYS_STATUS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace mavlink_common
{
template <class ContainerAllocator>
struct SYS_STATUS_
{
  typedef SYS_STATUS_<ContainerAllocator> Type;

  SYS_STATUS_()
    : sysid(0)
    , compid(0)
    , onboard_control_sensors_present(0)
    , onboard_control_sensors_enabled(0)
    , onboard_control_sensors_health(0)
    , load(0)
    , voltage_battery(0)
    , current_battery(0)
    , battery_remaining(0)
    , drop_rate_comm(0)
    , errors_comm(0)
    , errors_count1(0)
    , errors_count2(0)
    , errors_count3(0)
    , errors_count4(0)  {
    }
  SYS_STATUS_(const ContainerAllocator& _alloc)
    : sysid(0)
    , compid(0)
    , onboard_control_sensors_present(0)
    , onboard_control_sensors_enabled(0)
    , onboard_control_sensors_health(0)
    , load(0)
    , voltage_battery(0)
    , current_battery(0)
    , battery_remaining(0)
    , drop_rate_comm(0)
    , errors_comm(0)
    , errors_count1(0)
    , errors_count2(0)
    , errors_count3(0)
    , errors_count4(0)  {
    }



   typedef uint8_t _sysid_type;
  _sysid_type sysid;

   typedef uint8_t _compid_type;
  _compid_type compid;

   typedef uint32_t _onboard_control_sensors_present_type;
  _onboard_control_sensors_present_type onboard_control_sensors_present;

   typedef uint32_t _onboard_control_sensors_enabled_type;
  _onboard_control_sensors_enabled_type onboard_control_sensors_enabled;

   typedef uint32_t _onboard_control_sensors_health_type;
  _onboard_control_sensors_health_type onboard_control_sensors_health;

   typedef uint16_t _load_type;
  _load_type load;

   typedef uint16_t _voltage_battery_type;
  _voltage_battery_type voltage_battery;

   typedef int16_t _current_battery_type;
  _current_battery_type current_battery;

   typedef int8_t _battery_remaining_type;
  _battery_remaining_type battery_remaining;

   typedef uint16_t _drop_rate_comm_type;
  _drop_rate_comm_type drop_rate_comm;

   typedef uint16_t _errors_comm_type;
  _errors_comm_type errors_comm;

   typedef uint16_t _errors_count1_type;
  _errors_count1_type errors_count1;

   typedef uint16_t _errors_count2_type;
  _errors_count2_type errors_count2;

   typedef uint16_t _errors_count3_type;
  _errors_count3_type errors_count3;

   typedef uint16_t _errors_count4_type;
  _errors_count4_type errors_count4;


    enum { ID = 1 };
 

  typedef boost::shared_ptr< ::mavlink_common::SYS_STATUS_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mavlink_common::SYS_STATUS_<ContainerAllocator> const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;

}; // struct SYS_STATUS_

typedef ::mavlink_common::SYS_STATUS_<std::allocator<void> > SYS_STATUS;

typedef boost::shared_ptr< ::mavlink_common::SYS_STATUS > SYS_STATUSPtr;
typedef boost::shared_ptr< ::mavlink_common::SYS_STATUS const> SYS_STATUSConstPtr;

// constants requiring out of line definition

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mavlink_common::SYS_STATUS_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace mavlink_common

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/hydro/share/std_msgs/cmake/../msg'], 'mavlink_common': ['/root/ehang_ws/src/ghost/mavlink_common/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mavlink_common::SYS_STATUS_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mavlink_common::SYS_STATUS_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mavlink_common::SYS_STATUS_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "acc0ece737cc800a9f1925f9824acaf8";
  }

  static const char* value(const ::mavlink_common::SYS_STATUS_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xacc0ece737cc800aULL;
  static const uint64_t static_value2 = 0x9f1925f9824acaf8ULL;
};

template<class ContainerAllocator>
struct DataType< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mavlink_common/SYS_STATUS";
  }

  static const char* value(const ::mavlink_common::SYS_STATUS_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Automatically Generated in 2014-08-12 13:24:39.905967\n\
# MESSAGE: SYS_STATUS\n\
# Description:The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows wether the system is currently active or not and if an emergency occured. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occured it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.\n\
uint8 ID = 1\n\
uint8 sysid\n\
uint8 compid\n\
uint32 onboard_control_sensors_present\n\
uint32 onboard_control_sensors_enabled\n\
uint32 onboard_control_sensors_health\n\
uint16 load\n\
uint16 voltage_battery\n\
int16 current_battery\n\
int8 battery_remaining\n\
uint16 drop_rate_comm\n\
uint16 errors_comm\n\
uint16 errors_count1\n\
uint16 errors_count2\n\
uint16 errors_count3\n\
uint16 errors_count4\n\
";
  }

  static const char* value(const ::mavlink_common::SYS_STATUS_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.sysid);
      stream.next(m.compid);
      stream.next(m.onboard_control_sensors_present);
      stream.next(m.onboard_control_sensors_enabled);
      stream.next(m.onboard_control_sensors_health);
      stream.next(m.load);
      stream.next(m.voltage_battery);
      stream.next(m.current_battery);
      stream.next(m.battery_remaining);
      stream.next(m.drop_rate_comm);
      stream.next(m.errors_comm);
      stream.next(m.errors_count1);
      stream.next(m.errors_count2);
      stream.next(m.errors_count3);
      stream.next(m.errors_count4);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct SYS_STATUS_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mavlink_common::SYS_STATUS_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mavlink_common::SYS_STATUS_<ContainerAllocator>& v)
  {
    s << indent << "sysid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sysid);
    s << indent << "compid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.compid);
    s << indent << "onboard_control_sensors_present: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.onboard_control_sensors_present);
    s << indent << "onboard_control_sensors_enabled: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.onboard_control_sensors_enabled);
    s << indent << "onboard_control_sensors_health: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.onboard_control_sensors_health);
    s << indent << "load: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.load);
    s << indent << "voltage_battery: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.voltage_battery);
    s << indent << "current_battery: ";
    Printer<int16_t>::stream(s, indent + "  ", v.current_battery);
    s << indent << "battery_remaining: ";
    Printer<int8_t>::stream(s, indent + "  ", v.battery_remaining);
    s << indent << "drop_rate_comm: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.drop_rate_comm);
    s << indent << "errors_comm: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errors_comm);
    s << indent << "errors_count1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errors_count1);
    s << indent << "errors_count2: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errors_count2);
    s << indent << "errors_count3: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errors_count3);
    s << indent << "errors_count4: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.errors_count4);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MAVLINK_COMMON_MESSAGE_SYS_STATUS_H
